#include "arduino_secrets.h"
// OneWire - Version: Latest
#include <OneWire.h>
#include <DallasTemperature.h>
#include <ArduinoLowPower.h>
#include <ArduinoECCX08.h>

/*
  Sketch generated by the Arduino IoT Cloud Thing "Generationmakemkrwifi1010test"
  https://create.arduino.cc/cloud/things/52d7d447-10c4-4b92-acb3-6051d83c1755

  Arduino IoT Cloud Properties description

  The following variables are automatically generated and updated when changes are made to the Thing

  CloudTemperatureSensor water_Temp;
  CloudTemperatureSensor processor_Temp;
  CloudElectricPotention voltage;
  int rssi;

  Properties which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/

#include "thingProperties.h"

#define ONE_WIRE_BUS 4  // DS18B20 pin
OneWire oneWire(ONE_WIRE_BUS);
DallasTemperature DS18B20(&oneWire);
// We'll use this variable to store a found device address
DeviceAddress tempDeviceAddress;  
// Addresses of DS18B20s
uint8_t water_address[8] = { 0x28, 0x88, 0x84, 0xF6, 0x0C, 0x00, 0x00, 0x42 };
uint8_t processor_address[8] = { 0x28, 0x85, 0xB8, 0x96, 0x0A, 0x00, 0x00, 0xEC };

int numberOfDevices;
int connectCounter = 1;
int updCounter = 1;
int serialWasHere = 0;
int sync = 0;

void setup() {
  pinMode(LED_BUILTIN, OUTPUT);  // set LED pin to output
  // Initialize serial and wait for port to open:
  Serial.begin(9600);
  // This delay gives the chance to wait for a Serial Monitor without blocking if none is found
  for (unsigned long const serialBeginTime = millis(); !Serial && (millis() - serialBeginTime > 20000);) {}
  if (!Serial) {
    ledflash(2, 1000);
  } else {
    Serial.println("Setting serialWasHere");
    serialWasHere = 1;
  }
  // Start sensor
  DS18B20.begin();  // start DS18B20
  // Defined in thingProperties.h
  initProperties();
}

void loop() {
  if (serialWasHere == 1 && !Serial) {
    ledflash(1, 1000);
    Serial.begin(9600);
    for (unsigned long const serialBeginTime = millis(); !Serial && (millis() - serialBeginTime > 20000);) {}
    if (!Serial) {
      ledflash(4, 1000);
    }
    Serial.println("Serial Restarted");
  } else {
    Serial.println("Reusing Serial");
  }

  Serial.println("NINA_RESETN, LOW");
  digitalWrite(NINA_RESETN, LOW);  // activate nina
  delay(1500);
  DS18B20.begin();  // start DS18B20
  Serial.print("Free memory init: ");
  Serial.println(freeMemory());
  // Connect to Arduino IoT Cloud
  Serial.println("ArduinoCloud.begin");
  ArduinoCloud.begin(ArduinoIoTPreferredConnection, false);
  Serial.print("Free memory post-init: ");
  Serial.println(freeMemory());
  ArduinoCloud.addCallback(ArduinoIoTCloudEvent::CONNECT, doThisOnConnect);
  ArduinoCloud.addCallback(ArduinoIoTCloudEvent::SYNC, onIoTSync);

  /*
     The following function allows you to obtain more information
     related to the state of network and IoT Cloud connection and errors
     the higher number the more granular information youâll get.
     The default is 0 (only errors).
     Maximum is 4
  */
  setDebugMessageLevel(4);
  ArduinoCloud.printDebugInfo();
  delay(10000);
  Serial.println("ArduinoCloud.update 1");
  ArduinoCloud.update();
  // Grab a count of devices on the wire
  numberOfDevices = DS18B20.getDeviceCount();
  Serial.println(numberOfDevices);
  DS18B20.requestTemperatures();
  if (DS18B20.getTempC(water_address)) {
    water_Temp = DS18B20.getTempC(water_address);
    Serial.print("Water Temperature: ");
    Serial.println(water_Temp);
  }
  if (DS18B20.getTempC(processor_address)) {
    processor_Temp = DS18B20.getTempC(processor_address);
    Serial.print("Processor Temperature: ");
    Serial.println(processor_Temp);
  }

  voltage = 4.108887 * (float)analogRead(ADC_BATTERY) / 1000.0;  // read battery voltage
  Serial.print("Battery: ");
  Serial.println(voltage);

  //send data to the arduino iot cloud
  digitalWrite(LED_BUILTIN, HIGH);  // set LED to high during transmission
  Serial.println("Waiting for connection to Arduino IoT Cloud");
  Serial.println("count: ");
  while (ArduinoCloud.connected() == 0 && connectCounter < 40) {
    ArduinoCloud.update();
    Serial.print("... ");
    Serial.print(connectCounter++);
    Serial.println(" ...");
    digitalWrite(LED_BUILTIN, LOW);
    ledflash(1, 1000);
    digitalWrite(LED_BUILTIN, HIGH);
    rssi = int(WiFi.RSSI());
    Serial.print("WiFi RSSI: ");
    Serial.print(rssi);
    Serial.println(" dBm");
    Serial.print("Free Ram connect: ");
    Serial.println(freeMemory());
    delay(1000);
    Serial.print("Connected? ");
    Serial.println(ArduinoCloud.connected());
  }
  if (connectCounter >= 40 || freeMemory() <= 7000) {
    Serial.println("####### Trigger Reset #######");
    Serial.print("Free memory RESET: ");
    Serial.println(freeMemory());
    ledflash(20, 500);
    NVIC_SystemReset();
    delay(10000);
  }
  connectCounter = 1;
  delay(10000);
  while (sync == 0 && updCounter <= 40) {
    Serial.print("ArduinoCloud.update - ");
    Serial.println(updCounter++);
    Serial.print("Free memory upd: ");
    Serial.println(freeMemory());
    ArduinoCloud.update();
    delay(10000);
    Serial.print("Sync: ");
    Serial.println(sync);
  }
  sync = 0;
  updCounter = 0;
  digitalWrite(LED_BUILTIN, LOW);  // set LED low again  Serial.println();
  Serial.println("Sleeping 120000");
  delay(120000);
  Serial.println();
  Serial.println("WiFi.end");
  WiFi.end();
  delay(3000);

  // Send board to sleep mode
  Serial.println("NINA_RESETN, HIGH");
  digitalWrite(NINA_RESETN, HIGH);  // reset nina
  Serial.println("ECCX08.begin");
  ECCX08.begin();
  Serial.println("ECCX08.end");
  ECCX08.end();  // power down ECC508
  Serial.println("LowPower.deepSleep");
  Serial.end();
  delay(3000);  // wait 10 seconds for next round
  LowPower.deepSleep(10000);
  //LowPower.deepSleep(300000);
  ledflash(5, 1000);
  Serial.println("End of deepsleep");
}

// Function to flash the LED
void ledflash(int times, int length) {
  for (int i = 0; i < times; i++) {
    // Serial.println("In LED loop");
    digitalWrite(LED_BUILTIN, HIGH);  // set LED low again
    delay(length);
    digitalWrite(LED_BUILTIN, LOW);  // set LED low again
    delay(length);
  }
}

#ifdef __arm__
// should use uinstd.h to define sbrk but Due causes a conflict
extern "C" char* sbrk(int incr);
#else   // __ARM__
extern char *__brkval;
#endif  // __arm__

int freeMemory() {
  char top;
#ifdef __arm__
  return &top - reinterpret_cast<char*>(sbrk(0));
#elif defined(CORE_TEENSY) || (ARDUINO > 103 && ARDUINO != 151)
  return &top - __brkval;
#else   // __arm__
  return __brkval ? &top - __brkval : &top - __malloc_heap_start;
#endif  // __arm__
}

// function to print a device address
void printAddress(DeviceAddress deviceAddress) {
  for (uint8_t i = 0; i < 8; i++) {
    Serial.print("0x");
    if (deviceAddress[i] < 0x10) Serial.print("0");
    Serial.print(deviceAddress[i], HEX);
    if (i < 7) Serial.print(", ");
  }
  Serial.println("");
}

void doThisOnConnect() {
  Serial.println("Event CONNECT");
}

void onIoTSync() {
  Serial.println("Event SYNC");
  sync = 1;
}